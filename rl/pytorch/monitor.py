#
# ICFEM09/Proposition 5: Safety.py
# Generated by KeYmaera X
# v4 12/28/22
# called monitor_orig_new.py in mqian; edited 1/4/23

from typing import Callable
import numpy as np
import scaling

# Model parameters
class Params:
  def __init__(self, A: np.float64, b: np.float64, ep: np.float64):
    self.A = A
    self.b = b
    self.ep = ep
  def __str__(self) -> str:
    return "Params(" + "A=" + str(self.A) + ", " + "b=" + str(self.b) + ", " + "ep=" + str(self.ep) +  ")"

# State (control choices, environment measurements etc.)
class State:
  def __init__(self, a: np.float64, d: np.float64, do: np.float64, em: np.float64, m: np.float64, mo: np.float64, sb: np.float64, t: np.float64, v: np.float64, vdes: np.float64, z: np.float64):
    self.a = a
    self.d = d
    self.do = do
    self.em = em
    self.m = m
    self.mo = mo
    self.sb = sb
    self.t = t
    self.v = v
    self.vdes = vdes
    self.z = z
  def __str__(self) -> str:
    return "State(" + "a=" + str(self.a) + ", " + "d=" + str(self.d) + ", " + "do=" + str(self.do) + ", " + "em=" + str(self.em) + ", " + "m=" + str(self.m) + ", " + "mo=" + str(self.mo) + ", " + "sb=" + str(self.sb) + ", " + "t=" + str(self.t) + ", " + "v=" + str(self.v) + ", " + "vdes=" + str(self.vdes) + ", " + "z=" + str(self.z) +  ")"

# Values for resolving non-deterministic assignments in control code
class Input:
  def __init__(self, a: np.float64, d: np.float64, m: np.float64, vdes: np.float64):
    self.a = a
    self.d = d
    self.m = m
    self.vdes = vdes
  def __str__(self) -> str:
    return "Input(" + "a=" + str(self.a) + ", " + "d=" + str(self.d) + ", " + "m=" + str(self.m) + ", " + "vdes=" + str(self.vdes) +  ")"

# Verdict identifier and value
class Verdict:
  def __init__(self, id: np.float64, val: np.float64):
    self.id = id
    self.val = val
  def __str__(self) -> str:
    return "Verdict(" + "id=" + str(self.id) + ", " + "val=" + str(self.val) +  ")"

def checkInit(init: State, params: Params) -> Verdict:
  (((init.v)*(init.v))-((init.d)*(init.d)) <= ((np.float64(2.0))*(params.b))*((init.m)-(init.z))) and ((init.em == np.float64(0.0)) and ((init.v >= np.float64(0.0)) and ((params.A >= np.float64(0.0)) and ((params.ep >= np.float64(0.0)) and ((init.d >= np.float64(0.0)) and (params.b > np.float64(0.0)))))))

def Margin_692749292(pre, curr, params):
  return max((curr.vdes)-(pre.vdes), (pre.vdes)-(curr.vdes))
def Margin1265753075(pre, curr, params):
  return max((curr.t)-(pre.t), (pre.t)-(curr.t))
def Margin_1902204806(pre, curr, params):
  return max((curr.v)-(pre.v), (pre.v)-(curr.v))
def Margin220814156(pre, curr, params):
  return max((curr.a)-(pre.a), (pre.a)-(curr.a))
def Margin602202780(pre, curr, params):
  return max((curr.em)-(np.float64(1.0)), (np.float64(1.0))-(curr.em))
def Margin_1159009128(pre, curr, params):
  return max((curr.m)-(pre.m), (pre.m)-(curr.m))
def Margin707437964(pre, curr, params):
  return max((curr.sb)-(pre.sb), (pre.sb)-(curr.sb))
def Margin_1064769785(pre, curr, params):
  return max((curr.d)-(pre.d), (pre.d)-(curr.d))
def Margin_1589003265(pre, curr, params):
  return max((curr.mo)-(pre.mo), (pre.mo)-(curr.mo))
def Margin1817202462(pre, curr, params):
  return max((curr.do)-(pre.do), (pre.do)-(curr.do))
def Margin706996806(pre, curr, params):
  return max((curr.z)-(pre.z), (pre.z)-(curr.z))
def Margin908779580(pre, curr, params):
  return curr.d
def Margin_336431814(pre, curr, params):
  return pre.d
def Margin_1292656000(pre, curr, params):
  return (((np.float64(2.0))*(params.b))*((curr.m)-(pre.m)))-(((pre.d)*(pre.d))-((curr.d)*(curr.d)))
def Margin1827280351(pre, curr, params):
  return curr.vdes
def Margin352249001(pre, curr, params):
  return max((curr.em)-(pre.em), (pre.em)-(curr.em))
def Margin_267393619(pre, curr, params):
  return max((curr.mo)-(pre.m), (pre.m)-(curr.mo))
def Margin_1272453493(pre, curr, params):
  return max((curr.do)-(pre.d), (pre.d)-(curr.do))
def Cond_447929247(pre, curr, params):
  return ((pre.m)-(pre.z) <= ((((pre.v)*(pre.v))-((pre.d)*(pre.d)))/((np.float64(2.0))*(params.b)))+((((params.A)/(params.b))+(np.float64(1.0)))*((((params.A)/(np.float64(2.0)))*((params.ep)*(params.ep)))+((params.ep)*(pre.v))))) or (pre.em == np.float64(1.0))
def Cond111872809(pre, curr, params):
  return curr.sb == ((((pre.v)*(pre.v))-((pre.d)*(pre.d)))/((np.float64(2.0))*(params.b)))+((((params.A)/(params.b))+(np.float64(1.0)))*((((params.A)/(np.float64(2.0)))*((params.ep)*(params.ep)))+((params.ep)*(pre.v))))
def Margin1664663636(pre, curr, params):
  return params.ep
def Margin_1205389256(pre, curr, params):
  return pre.v
def Margin_1247279157(pre, curr, params):
  return -(min(((pre.m)-(pre.z))-(((((pre.v)*(pre.v))-((pre.d)*(pre.d)))/((np.float64(2.0))*(params.b)))+((((params.A)/(params.b))+(np.float64(1.0)))*((((params.A)/(np.float64(2.0)))*((params.ep)*(params.ep)))+((params.ep)*(pre.v))))), max((pre.em)-(np.float64(1.0)), (np.float64(1.0))-(pre.em))))
def Margin_79975035(pre, curr, params):
  return max(curr.t, -(curr.t))
def Margin362783957(pre, curr, params):
  return max((curr.a)-(-(params.b)), (-(params.b))-(curr.a))
def Margin_813897380(pre, curr, params):
  return max((curr.sb)-(((((pre.v)*(pre.v))-((pre.d)*(pre.d)))/((np.float64(2.0))*(params.b)))+((((params.A)/(params.b))+(np.float64(1.0)))*((((params.A)/(np.float64(2.0)))*((params.ep)*(params.ep)))+((params.ep)*(pre.v))))), (((((pre.v)*(pre.v))-((pre.d)*(pre.d)))/((np.float64(2.0))*(params.b)))+((((params.A)/(params.b))+(np.float64(1.0)))*((((params.A)/(np.float64(2.0)))*((params.ep)*(params.ep)))+((params.ep)*(pre.v)))))-(curr.sb))
def Margin1654840113(pre, curr, params):
  return min(((pre.m)-(pre.z))-(((((pre.v)*(pre.v))-((pre.d)*(pre.d)))/((np.float64(2.0))*(params.b)))+((((params.A)/(params.b))+(np.float64(1.0)))*((((params.A)/(np.float64(2.0)))*((params.ep)*(params.ep)))+((params.ep)*(pre.v))))), max((pre.em)-(np.float64(1.0)), (np.float64(1.0))-(pre.em)))
def Cond1342843786(pre, curr, params):
  return (pre.m)-(pre.z) > ((((pre.v)*(pre.v))-((pre.d)*(pre.d)))/((np.float64(2.0))*(params.b)))+((((params.A)/(params.b))+(np.float64(1.0)))*((((params.A)/(np.float64(2.0)))*((params.ep)*(params.ep)))+((params.ep)*(pre.v))))
def Margin506306233(pre, curr, params):
  return -(min((np.float64(1.0))-(pre.em), (pre.em)-(np.float64(1.0))))
def Margin1342843786(pre, curr, params):
  return ((pre.m)-(pre.z))-(((((pre.v)*(pre.v))-((pre.d)*(pre.d)))/((np.float64(2.0))*(params.b)))+((((params.A)/(params.b))+(np.float64(1.0)))*((((params.A)/(np.float64(2.0)))*((params.ep)*(params.ep)))+((params.ep)*(pre.v)))))
def Margin1255139035(pre, curr, params):
  return min((np.float64(1.0))-(pre.em), (pre.em)-(np.float64(1.0)))
def Or_717011714(pre, curr, params):
  if Cond_447929247(pre, curr, params):
    if pre.v >= np.float64(0.0):
      if np.float64(0.0) <= params.ep:
        if curr.z == pre.z:
          if curr.do == pre.do:
            if curr.mo == pre.mo:
              if curr.d == pre.d:
                if Cond111872809(pre, curr, params):
                  if curr.m == pre.m:
                    if curr.em == pre.em:
                      if curr.a == -(params.b):
                        if curr.v == pre.v:
                          if curr.t == np.float64(0.0):
                            if curr.vdes == pre.vdes:
                              verdicts = [
                               Verdict(1, Margin1664663636(pre, curr, params)),
                               Verdict(1, Margin_1205389256(pre, curr, params)),
                               Verdict(1, Margin_1247279157(pre, curr, params))
                               
                              ]
                              nonMeasureZeroVerdicts = filter(lambda v: v.id != 0, verdicts)
                              return min(nonMeasureZeroVerdicts, key=lambda v: v.val, default=Verdict(0, np.float64(0.0)))
                            else:
                              return Verdict(-1, -Margin_692749292(pre, curr, params))
                          else:
                            return Verdict(-19, -Margin_79975035(pre, curr, params))
                        else:
                          return Verdict(-3, -Margin_1902204806(pre, curr, params))
                      else:
                        return Verdict(-20, -Margin362783957(pre, curr, params))
                    else:
                      return Verdict(-12, -Margin352249001(pre, curr, params))
                  else:
                    return Verdict(-6, -Margin_1159009128(pre, curr, params))
                else:
                  return Verdict(-21, -Margin_813897380(pre, curr, params))
              else:
                return Verdict(-8, -Margin_1064769785(pre, curr, params))
            else:
              return Verdict(-9, -Margin_1589003265(pre, curr, params))
          else:
            return Verdict(-10, -Margin1817202462(pre, curr, params))
        else:
          return Verdict(-11, -Margin706996806(pre, curr, params))
      else:
        return Verdict(-22, Margin1664663636(pre, curr, params))
    else:
      return Verdict(-23, Margin_1205389256(pre, curr, params))
  else:
    return Verdict(-24, -Margin1654840113(pre, curr, params))
def Or_561166024(pre, curr, params):
  if Cond1342843786(pre, curr, params):
    if pre.em != np.float64(1.0):
      if pre.v >= np.float64(0.0):
        if np.float64(0.0) <= params.ep:
          if curr.z == pre.z:
            if curr.do == pre.do:
              if curr.mo == pre.mo:
                if curr.d == pre.d:
                  if Cond111872809(pre, curr, params):
                    if curr.m == pre.m:
                      if curr.em == pre.em:
                        if curr.v == pre.v:
                          if curr.t == np.float64(0.0):
                            if curr.vdes == pre.vdes:
                              verdicts = [
                               Verdict(1, Margin1664663636(pre, curr, params)),
                               Verdict(1, Margin_1205389256(pre, curr, params)),
                               Verdict(1, Margin506306233(pre, curr, params)),
                               Verdict(1, Margin1342843786(pre, curr, params))
                               
                              ]
                              nonMeasureZeroVerdicts = filter(lambda v: v.id != 0, verdicts)
                              return min(nonMeasureZeroVerdicts, key=lambda v: v.val, default=Verdict(0, np.float64(0.0)))
                            else:
                              return Verdict(-1, -Margin_692749292(pre, curr, params))
                          else:
                            return Verdict(-19, -Margin_79975035(pre, curr, params))
                        else:
                          return Verdict(-3, -Margin_1902204806(pre, curr, params))
                      else:
                        return Verdict(-12, -Margin352249001(pre, curr, params))
                    else:
                      return Verdict(-6, -Margin_1159009128(pre, curr, params))
                  else:
                    return Verdict(-21, -Margin_813897380(pre, curr, params))
                else:
                  return Verdict(-8, -Margin_1064769785(pre, curr, params))
              else:
                return Verdict(-9, -Margin_1589003265(pre, curr, params))
            else:
              return Verdict(-10, -Margin1817202462(pre, curr, params))
          else:
            return Verdict(-11, -Margin706996806(pre, curr, params))
        else:
          return Verdict(-22, Margin1664663636(pre, curr, params))
      else:
        return Verdict(-23, Margin_1205389256(pre, curr, params))
    else:
      return Verdict(-25, -Margin1255139035(pre, curr, params))
  else:
    return Verdict(-26, Margin1342843786(pre, curr, params))
def Margin_2041402958(pre, curr, params):
  return (params.A)-(curr.a)
def Margin1405018772(pre, curr, params):
  return (curr.a)-(-(params.b))
def Margin1370404390(pre, curr, params):
  return (pre.vdes)-(pre.v)
def And1337443618(pre, curr, params):
  verdicts = [
   
   Or_717011714(pre, curr, params),
   Or_561166024(pre, curr, params)
  ]
  nonMeasureZeroVerdicts = filter(lambda v: v.id != 0, verdicts)
  return max(nonMeasureZeroVerdicts, key=lambda v: v.val, default=Verdict(0, np.float64(0.0)))
def Margin_981904362(pre, curr, params):
  return -(curr.a)
def Margin447627440(pre, curr, params):
  return (pre.v)-(pre.vdes)
def Margin_712184673(pre, curr, params):
  return curr.a
def Or_863133610(pre, curr, params):
  if curr.z == pre.z:
    if curr.do == pre.do:
      if curr.mo == pre.mo:
        if curr.d == pre.d:
          if curr.sb == pre.sb:
            if curr.m == pre.m:
              if curr.em == np.float64(1.0):
                if curr.a == pre.a:
                  if curr.v == pre.v:
                    if curr.t == pre.t:
                      if curr.vdes == pre.vdes:
                        Verdict(0, np.float64(0.0))
                      else:
                        return Verdict(-1, -Margin_692749292(pre, curr, params))
                    else:
                      return Verdict(-2, -Margin1265753075(pre, curr, params))
                  else:
                    return Verdict(-3, -Margin_1902204806(pre, curr, params))
                else:
                  return Verdict(-4, -Margin220814156(pre, curr, params))
              else:
                return Verdict(-5, -Margin602202780(pre, curr, params))
            else:
              return Verdict(-6, -Margin_1159009128(pre, curr, params))
          else:
            return Verdict(-7, -Margin707437964(pre, curr, params))
        else:
          return Verdict(-8, -Margin_1064769785(pre, curr, params))
      else:
        return Verdict(-9, -Margin_1589003265(pre, curr, params))
    else:
      return Verdict(-10, -Margin1817202462(pre, curr, params))
  else:
    return Verdict(-11, -Margin706996806(pre, curr, params))
def Or519337819(pre, curr, params):
  if curr.vdes >= np.float64(0.0):
    if ((pre.d)*(pre.d))-((curr.d)*(curr.d)) <= ((np.float64(2.0))*(params.b))*((curr.m)-(pre.m)):
      if pre.d >= np.float64(0.0):
        if curr.d >= np.float64(0.0):
          if curr.z == pre.z:
            if curr.do == pre.d:
              if curr.mo == pre.m:
                if curr.sb == pre.sb:
                  if curr.em == pre.em:
                    if curr.a == pre.a:
                      if curr.v == pre.v:
                        if curr.t == pre.t:
                          verdicts = [
                           Verdict(1, Margin908779580(pre, curr, params)),
                           Verdict(1, Margin_336431814(pre, curr, params)),
                           Verdict(1, Margin_1292656000(pre, curr, params)),
                           Verdict(1, Margin1827280351(pre, curr, params))
                           
                          ]
                          nonMeasureZeroVerdicts = filter(lambda v: v.id != 0, verdicts)
                          return min(nonMeasureZeroVerdicts, key=lambda v: v.val, default=Verdict(0, np.float64(0.0)))
                        else:
                          return Verdict(-2, -Margin1265753075(pre, curr, params))
                      else:
                        return Verdict(-3, -Margin_1902204806(pre, curr, params))
                    else:
                      return Verdict(-4, -Margin220814156(pre, curr, params))
                  else:
                    return Verdict(-12, -Margin352249001(pre, curr, params))
                else:
                  return Verdict(-7, -Margin707437964(pre, curr, params))
              else:
                return Verdict(-13, -Margin_267393619(pre, curr, params))
            else:
              return Verdict(-14, -Margin_1272453493(pre, curr, params))
          else:
            return Verdict(-11, -Margin706996806(pre, curr, params))
        else:
          return Verdict(-15, Margin908779580(pre, curr, params))
      else:
        return Verdict(-16, Margin_336431814(pre, curr, params))
    else:
      return Verdict(-17, Margin_1292656000(pre, curr, params))
  else:
    return Verdict(-18, Margin1827280351(pre, curr, params))
def Or_54826926(pre, curr, params):
  if pre.v <= pre.vdes:
    if -(params.b) <= curr.a:
      if curr.a <= params.A:
        verdicts = [
         Verdict(1, Margin_2041402958(pre, curr, params)),
         Verdict(1, Margin1405018772(pre, curr, params)),
         Verdict(1, Margin1370404390(pre, curr, params)),
         And1337443618(pre, curr, params)
        ]
        nonMeasureZeroVerdicts = filter(lambda v: v.id != 0, verdicts)
        return min(nonMeasureZeroVerdicts, key=lambda v: v.val, default=Verdict(0, np.float64(0.0)))
      else:
        return Verdict(-27, Margin_2041402958(pre, curr, params))
    else:
      return Verdict(-28, Margin1405018772(pre, curr, params))
  else:
    return Verdict(-29, scaling.velocity(Margin1370404390(pre, curr, params))) #pre.vdes - pre.v 
def Or502716648(pre, curr, params):
  if pre.v >= pre.vdes:
    if -(params.b) <= curr.a:
      if curr.a <= np.float64(0.0):
        verdicts = [
         Verdict(1, Margin_981904362(pre, curr, params)),
         Verdict(1, Margin1405018772(pre, curr, params)),
         Verdict(1, Margin447627440(pre, curr, params)),
         And1337443618(pre, curr, params)
        ]
        nonMeasureZeroVerdicts = filter(lambda v: v.id != 0, verdicts)
        return min(nonMeasureZeroVerdicts, key=lambda v: v.val, default=Verdict(0, np.float64(0.0)))
      else:
        return Verdict(-30, -Margin_712184673(pre, curr, params))
    else:
      return Verdict(-28, Margin1405018772(pre, curr, params))
  else:
    return Verdict(-31, scaling.velocity2(Margin447627440(pre, curr, params))) #pre.v - pre.vdes

def boundaryDist(pre: State, curr: State, params: Params) -> Verdict:
  '''
  Computes distance to safety boundary on prior and current state (>=0 is safe, <0 is unsafe)
  '''
  verdicts = [
   
   Or_863133610(pre, curr, params),
   Or519337819(pre, curr, params),
   Or_54826926(pre, curr, params),
   Or502716648(pre, curr, params)
  ]
  nonMeasureZeroVerdicts = filter(lambda v: v.id != 0, verdicts)
  return max(nonMeasureZeroVerdicts, key=lambda v: v.val, default=Verdict(0, np.float64(0.0)))

def monitorSatisfied(pre: State, curr: State, params: Params) -> bool:
  '''
  Evaluates monitor condition in prior and current state
  '''
  return boundaryDist(pre,curr,params).val >= 0

def monitoredCtrl(curr: State, params: Params, inp: State,
                  ctrl: Callable[[State, State, Params], State],
                  fallback: Callable[[State, State, Params], State]) -> State:
  '''
  Run controller `ctrl` monitored, return `fallback` if `ctrl` violates monitor
  '''
  pre = curr
  post = ctrl(pre,params,inp)
  if monitorSatisfied(pre,post,params) == True:
    return post
  else:
    return fallback(pre,params,inp)
